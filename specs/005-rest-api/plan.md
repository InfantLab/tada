# Implementation Plan: Ta-Da! REST API

**Branch**: `005-rest-api` | **Date**: 2026-02-01 | **Spec**: [spec.md](spec.md)
**Input**: Feature specification from `/specs/005-rest-api/spec.md`

## Summary

Implement a REST API (v1) for Ta-Da! enabling external integrations (OpenClaw, voice assistants, automation tools) to read and write life activity data. The API provides authenticated access to entries, rhythms, insights, exports, and webhooks with rate limiting and comprehensive error handling. Primary use case is OpenClaw skill for voice-based daily summaries and hands-free entry creation.

**Technical Approach**: Build RESTful endpoints in Nuxt 3 server routes using existing Drizzle ORM schema, add API key authentication middleware, implement service layer for business logic (streaks, patterns, exports), and leverage SQLite for data persistence and caching.

## Technical Context

**Language/Version**: TypeScript 5.x via Nuxt 3.15.1 (server routes)
**Primary Dependencies**: Nuxt 3, Drizzle ORM 0.38.3, Lucia Auth v3.2.2, Zod 3.23.8, Bun 1.3.5 (runtime)
**Storage**: SQLite (via @libsql/client 0.14.0) with Drizzle ORM
**Testing**: Vitest 4.x with @nuxt/test-utils for API endpoint testing
**Target Platform**: Linux server (production), cross-platform development (Bun runtime)
**Project Type**: Web application (Nuxt fullstack PWA with server API routes)
**Performance Goals**:
- <500ms p90 response time for entry queries
- <5s for pattern detection (first run), <100ms (cached)
- Support 100 concurrent authenticated requests
- 1000 req/hour per API key (configurable per endpoint)

**Constraints**:
- Must integrate with existing Lucia Auth session system
- Must use existing Drizzle schema (extend with API keys table)
- Must maintain PWA functionality (API doesn't affect client)
- SQLite write serialization (handle concurrent writes gracefully)
- Pattern detection computationally expensive (requires caching strategy)

**Scale/Scope**:
- Target: 10-100 API consumers initially (OpenClaw primary)
- User data: 4000+ entries typical, up to 10 years historical data
- Export operations may scan large datasets (needs pagination/streaming)
- Single-tenant (one user per API key, multi-key per user supported)

## Constitution Check

*GATE: Must pass before Phase 0 research. Re-check after Phase 1 design.*

**Status**: ✅ PASS (No project constitution defined - using industry best practices)

### Evaluated Gates

- **Security**: API keys hashed with bcrypt ✓, permissions-based access control ✓
- **Testing**: Vitest test coverage required for all endpoints ✓
- **Documentation**: OpenAPI/Swagger spec generation recommended ✓
- **Backward Compatibility**: V1 API versioning allows future v2 without breaking changes ✓
- **Observability**: Structured logging, request IDs, error tracking required ✓

### Design Decisions Requiring Validation

1. **Service Layer Pattern**: Separate business logic (rhythm calculations, pattern detection) from API routes into `app/server/services/` - keeps routes thin, enables reuse, improves testability
2. **Middleware-based Auth**: Use Nuxt server middleware at `/api/v1/_middleware.ts` for authentication - centralizes security, applies to all v1 endpoints automatically
3. **Response Formatting Utility**: Standardize all API responses via `app/server/utils/response.ts` - ensures consistency, simplifies error handling
4. **Cache Layer**: Implement insight cache table in Drizzle schema - expensive pattern detection requires persistence, TTL-based invalidation

## Project Structure

### Documentation (this feature)

```text
specs/005-rest-api/
├── plan.md              # This file
├── research.md          # Phase 0: Research findings
├── data-model.md        # Phase 1: Database schema additions
├── quickstart.md        # Phase 1: API quickstart guide
├── contracts/           # Phase 1: API endpoint contracts
│   ├── auth.md          # Authentication endpoints
│   ├── entries.md       # Entry CRUD operations
│   ├── rhythms.md       # Rhythm and streak endpoints
│   ├── insights.md      # Pattern detection and analytics
│   ├── export.md        # Export formats and endpoints
│   ├── import.md        # Import endpoints
│   ├── webhooks.md      # Webhook management
│   └── user.md          # User settings endpoints
└── tasks.md             # Phase 2: Generated by /speckit.tasks
```

### Source Code (repository root)

```text
app/
├── server/
│   ├── api/
│   │   └── v1/                      # New: API v1 namespace
│   │       ├── _middleware.ts       # New: Auth + rate limiting
│   │       ├── auth/
│   │       │   ├── keys.get.ts      # List API keys
│   │       │   ├── keys.post.ts     # Generate API key
│   │       │   └── keys/[id].delete.ts  # Revoke key
│   │       ├── entries/
│   │       │   ├── index.get.ts     # List entries (filters, pagination)
│   │       │   ├── index.post.ts    # Create entry
│   │       │   ├── [id].get.ts      # Get single entry
│   │       │   ├── [id].patch.ts    # Update entry
│   │       │   ├── [id].delete.ts   # Soft delete entry
│   │       │   └── bulk.post.ts     # Bulk operations
│   │       ├── rhythms/
│   │       │   ├── index.get.ts     # All rhythms
│   │       │   ├── [id].get.ts      # Single rhythm
│   │       │   ├── [id].post.ts     # Create/update rhythm
│   │       │   └── [id]/history.get.ts  # Historical data
│   │       ├── insights/
│   │       │   ├── patterns.get.ts  # Pattern detection
│   │       │   ├── correlations.get.ts  # Correlation analysis
│   │       │   └── summary.get.ts   # Period summaries
│   │       ├── export/
│   │       │   ├── entries.get.ts   # JSON/CSV/Markdown export
│   │       │   └── obsidian.get.ts  # Obsidian-formatted export
│   │       ├── import/
│   │       │   ├── csv.post.ts      # Generic CSV import
│   │       │   ├── insight-timer.post.ts  # Insight Timer preset
│   │       │   └── json.post.ts     # JSON import
│   │       ├── webhooks/
│   │       │   ├── index.get.ts     # List webhooks
│   │       │   ├── index.post.ts    # Register webhook
│   │       │   ├── [id].patch.ts    # Update webhook
│   │       │   ├── [id].delete.ts   # Delete webhook
│   │       │   └── [id]/test.post.ts  # Test webhook
│   │       └── user/
│   │           ├── index.get.ts     # Get user profile
│   │           └── settings.patch.ts  # Update settings
│   ├── db/
│   │   └── schema.ts                # Modified: Add apiKeys, webhooks, insightCache tables
│   ├── services/                    # New: Business logic layer
│   │   ├── entries.ts               # Entry CRUD with validation
│   │   ├── rhythms.ts               # Streak calculation algorithms
│   │   ├── insights.ts              # Pattern detection logic
│   │   ├── export.ts                # Format converters (JSON/CSV/MD)
│   │   ├── webhooks.ts              # Webhook delivery + retry logic
│   │   └── rate-limit.ts            # Rate limiting implementation
│   └── utils/
│       ├── api-key.ts               # New: API key generation + validation
│       ├── response.ts              # New: Standard API response formatting
│       └── permissions.ts           # New: Permission checking helpers
├── tests/
│   └── api/                         # New: API endpoint tests
│       └── v1/
│           ├── auth.test.ts
│           ├── entries.test.ts
│           ├── rhythms.test.ts
│           ├── insights.test.ts
│           ├── export.test.ts
│           ├── webhooks.test.ts
│           └── rate-limit.test.ts
└── types/
    └── api.d.ts                     # New: API type definitions
```

**Structure Decision**: Using Nuxt 3's file-based routing for API endpoints under `app/server/api/v1/`. This leverages Nuxt's automatic route registration, middleware chaining, and development hot-reload. Service layer separates business logic from HTTP handling for better testability. Tests colocated in `tests/api/` mirror the endpoint structure.

## Complexity Tracking

> No constitution violations - using standard patterns appropriate for the feature.

*This section intentionally left empty as no complexity justifications are required.*

## Phase 0: Research & Discovery

### Objectives

1. Analyze existing authentication system (Lucia Auth) to determine integration approach
2. Review existing database schema to identify required additions
3. Research rate limiting implementations for Nuxt/H3
4. Investigate pattern detection algorithms (correlation, temporal, trend analysis)
5. Study export format requirements (Obsidian markdown specifics)
6. Evaluate webhook delivery patterns and retry strategies

### Key Questions to Answer

- **Q1**: How to integrate API key auth alongside existing Lucia session auth?
  - **Decision**: Use Nuxt middleware to check for Bearer token, validate against API keys table, fallback to session validation for backward compatibility

- **Q2**: What rate limiting strategy works with SQLite (no Redis)?
  - **Decision**: In-memory LRU cache with sliding window counter, backed by periodic SQLite logging for audit

- **Q3**: How to handle expensive pattern detection queries?
  - **Decision**: Implement insights cache table with TTL, serve cached results when available, compute async when stale

- **Q4**: What's the Obsidian daily note markdown format?
  - **Decision**: Use YAML frontmatter + markdown sections, reference Obsidian Dataview plugin format

- **Q5**: Should webhooks be synchronous or async?
  - **Decision**: Async delivery via background job queue (simple in-process queue for MVP, external queue for scale)

**Output**: [research.md](research.md) document with findings

## Phase 1: Design & Contracts

### Data Model Additions

**New Tables** (to add to `app/server/db/schema.ts`):

1. **apiKeys**: Store hashed API keys with permissions and metadata
2. **webhooks**: Register webhook URLs with event subscriptions
3. **insightCache**: Cache expensive pattern detection results
4. **rateLimits** (optional): Persistent rate limit tracking for auditing

**Modified Tables**: None - existing `entries` table supports all required fields

**Output**: [data-model.md](data-model.md) with full Drizzle schema definitions

### API Contracts

For each endpoint group, define:
- Request parameters (query, body, headers)
- Response format (success, error cases)
- Status codes
- Zod validation schemas
- Example requests/responses

**Output**: Individual contract files in `contracts/` directory

### Quickstart Guide

Developer-facing documentation including:
- How to generate an API key
- Making the first authenticated request
- Common use cases (fetch today's entries, create entry, get streaks)
- Error handling patterns
- Rate limit information

**Output**: [quickstart.md](quickstart.md)

## Phase 2: Implementation Planning

*This phase is handled by the `/speckit.tasks` command, which generates [tasks.md](tasks.md) with:*
- Setup tasks (dependencies, migrations, middleware)
- Foundational tasks (auth, response utils, error handling)
- Per-user-story implementation tasks (P1-P7 from spec)
- Testing tasks
- Documentation tasks

## Next Steps

1. ✅ **Complete Phase 0 Research** → Generate `research.md`
2. ✅ **Complete Phase 1 Design** → Generate `data-model.md`, `contracts/`, `quickstart.md`
3. **Run `/speckit.tasks`** → Generate implementation task breakdown
4. **Begin P1 Implementation** → OpenClaw Daily Summary (MVP endpoints)

## Dependencies & Risks

### External Dependencies
- None - all dependencies already in package.json

### Internal Dependencies
- Existing Lucia Auth system must remain functional
- Current database schema must support querying patterns (indexes may be needed)
- Existing entry CRUD operations should be refactored to use new service layer

### Risks & Mitigations

| Risk | Impact | Mitigation |
|------|--------|-----------|
| SQLite write contention with concurrent API requests | Medium | Implement connection pooling, use WAL mode, graceful error handling |
| Pattern detection too slow for real-time requests | High | Implement caching layer, set realistic timeout (5s), allow async computation |
| API key storage security | High | Use bcrypt cost 12+, store only hashes, implement key rotation |
| Webhook delivery failures causing data loss | Medium | Implement persistent queue, exponential backoff, dead letter queue |
| Rate limiting bypassed via multiple keys | Low | Track at user level, not just key level, implement IP-based fallback |

### Performance Considerations

- **Database Indexes**: Add composite indexes on `(userId, startTime)`, `(userId, type, category)` for efficient filtering
- **Query Optimization**: Use Drizzle's query builder efficiently, avoid N+1 queries in rhythm calculations
- **Caching Strategy**: Insight cache with 1-hour TTL, response caching via HTTP headers for static exports
- **Pagination**: Always paginate large result sets, use cursor-based pagination for real-time data

## Open Questions for Implementation

1. Should we implement cursor-based pagination immediately or start with offset-based?
   - **Recommendation**: Start with offset (simpler), add cursor for specific endpoints if needed

2. What's the webhook retry policy exactly?
   - **Recommendation**: 3 retries with exponential backoff (1s, 5s, 25s), then disable

3. Should pattern detection support custom algorithms or just built-ins?
   - **Recommendation**: Built-in patterns for MVP, custom support in v2

4. How to handle timezone for all-day events when exporting?
   - **Recommendation**: Store user's preferred timezone, convert on export

5. Should we version the API response format?
   - **Recommendation**: Not needed for v1, but include `apiVersion: "1.0"` in meta for future compatibility
